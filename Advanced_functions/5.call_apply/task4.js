/*Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку, передавая вызов в f не более одного раза в ms миллисекунд. Те вызовы, которые попадают в период «торможения», игнорируются.

Отличие от debounce – если проигнорированный вызов является последним во время «задержки», то он выполняется в конце.

Давайте рассмотрим реальное применение, чтобы лучше понять это требование и выяснить, откуда оно взято.

Например, мы хотим отслеживать движения мыши.

В браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его местоположение. Во время активного использования мыши эта функция запускается очень часто, это может происходить около 100 раз в секунду (каждые 10 мс).

Мы бы хотели обновлять информацию на странице при передвижениях.

…Но функция обновления update() слишком ресурсоёмкая, чтобы делать это при каждом микродвижении. Да и нет смысла делать обновление чаще, чем один раз в 1000 мс.

Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 1000) как функцию, которая будет запускаться при каждом перемещении указателя вместо оригинальной update(). Декоратор будет вызываться часто, но передавать вызов в update() максимум раз в 1000 мс.

Визуально это будет выглядеть вот так:

Для первого движения указателя декорированный вариант сразу передаёт вызов в update. Это важно, т.к. пользователь сразу видит нашу реакцию на его перемещение.
Затем, когда указатель продолжает движение, в течение 1000 мс ничего не происходит. Декорированный вариант игнорирует вызовы.
По истечению 1000 мс происходит ещё один вызов update с последними координатами.
Затем, наконец, указатель где-то останавливается. Декорированный вариант ждёт, пока не истечёт 1000 мс, и затем вызывает update с последними координатами. В итоге окончательные координаты указателя тоже обработаны.

P.S. Аргументы и контекст this, переданные в f1000, должны быть переданы в оригинальную f.*/

function f(a) {
  console.log(a);
}

function throttle(f, ms) {
  let isReady = true,
    context = null,
    lastThis = null;

  return function wrapper() {
    if (isReady) {
      console.log((Date.now() % 100000) / 1000);
      f.apply(this, arguments);
      isReady = false;
      setTimeout(() => {
        isReady = true;
        if (context) {
          console.log(`now will start last remembered f(${context[0]})`);
          wrapper.apply(lastThis, context);
          context = null;
          lastThis = null;
        }
      }, ms);
    } else {
      context = arguments;
      lastThis = this;
    }
  };
}

// f1000 передаёт вызовы f максимум раз в 1000 мс

let f1000 = throttle(f, 1000);

let counter = 1;

setTimeout(function go() {
  f1000(counter);
  // console.log(counter);
  if (counter < 30) setTimeout(go, 99);
  counter++;
}, 99);
